---
title: "UMAP_simple"
author: "Diogo Esteves"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

# Instalação e "loading" de Bibliotecas, Pacotes e Dependências

```{r dependencies1}
# Define uma função para instalar pacotes se eles não estiverem já instalados
ensure_packages <- function(packages) {
  new_packages <- packages[!packages %in% installed.packages()[,"Package"]]
  if(length(new_packages) > 0) install.packages(new_packages)
  lapply(packages, library, character.only = TRUE)
}

# Pacotes do CRAN
cran_packages <- c("R.utils", "ggplot2", "dplyr", "data.table", "plotly", 
                   "viridis", "htmlwidgets", "VGAM", "forcats", "devtools", "knitr")
ensure_packages(cran_packages)

# Pacotes do Bioconductor
bioc_packages <- c("SingleCellExperiment", "GenomeInfoDb", "SummarizedExperiment",
                   "DelayedArray", "HDF5Array", "BiocParallel", "SRAdb",
                   "BiocGenerics", "DelayedMatrixStats", "limma", "lme4",
                   "S4Vectors", "batchelor", "terra", "ggrastr", "scater", "scran")

if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}
BiocManager::install(bioc_packages, ask = FALSE)
```

## Instalação de Pacotes Python via Reticulate

```{r dependencies2}
# Função para instalar pacotes Python e tratar erros
install_python_package <- function(package) {
  tryCatch({
    reticulate::py_install(package, pip = TRUE)
    cat(paste("Instalação do pacote", package, "completada.\n"))
  }, error = function(e) {
    cat(paste("Erro na instalação do pacote", package, ":", e$message, "\n"))
  })
}

# Instalar pacotes p/Python necessários
install_python_package('umap-learn')
install_python_package('louvain')

```
### Configuração do Diretório de Trabalho e loading das Bibliotecas

```{r libraries}
# Automaticamente define a working directory para o local deste ficheiro .Rmd
setwd(dirname(rstudioapi::getSourceEditorContext()$path))

library(monocle3)
library(ggplot2)
library(R.utils)
library(dplyr)
library(Seurat)
library(SingleCellExperiment)
library(BiocParallel)
library(parallel)
library(Matrix)
library(DelayedArray)
library(DelayedMatrixStats)
library(scater)
library(DESeq2)
library(scran)
```

# Download dos Dados e Pré-Processamento
Ficheiros:
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE202639

AVISO: São muitos GBs certifiquem-se que a máquina reúne os requisitos, que estão na diretoria certa e a correr em modo administrador antes de avançar mais no script.

```{r download-data1}
# Automaticamente define a working directory para o local deste ficheiro .Rmd
setwd(dirname(rstudioapi::getSourceEditorContext()$path))

# Função para baixar e extrair arquivos apenas se eles não existirem
download_and_extract <- function(urls, dests) {
  for (i in seq_along(urls)) {
    if (!file.exists(dests[i])) {
      download.file(urls[i], dests[i], method = "libcurl", mode = "wb")
      if (file.exists(dests[i])) {
        utils::unzip(dests[i], exdir = dirname(dests[i]))
        message(paste("Arquivo", dests[i], "baixado e extraído com sucesso."))
      } else {
        message(paste("Falha no download do arquivo:", urls[i]))
      }
    } else {
      message(paste("Arquivo já existe e não será baixado novamente:", dests[i]))
    }
  }
}

# Executando a função para os datasets necessários
files_to_download <- c("https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE202639&format=file&file=GSE202639%5Fzperturb%5Ffull%5Fcds%2ERDS%2Egz",
                       "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE202639&format=file&file=GSE202639%5Fzperturb%5Ffull%5Fcell%5Fmetadata%2Ecsv%2Egz",
                       "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE202639&format=file&file=GSE202639%5Fzperturb%5Ffull%5Fgene%5Fmetadata%2Ecsv%2Egz",
                       "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE202639&format=file&file=GSE202639%5Fzperturb%5Ffull%5Fraw%5Fcounts%2ERDS%2Egz")


dest_files <- c("GSE202639_zperturb_full_cds.RDS.gz", "GSE202639_zperturb_full_cell_metadata.csv.gz", "GSE202639_zperturb_full_gene_metadata.csv.gz", "GSE202639_zperturb_full_raw_counts.RDS.gz")

download_and_extract(files_to_download, dest_files)
```

## Loading dos Dados

```{r data-load1}
# Automaticamente define a working directory para o local deste ficheiro .Rmd
setwd(dirname(rstudioapi::getSourceEditorContext()$path))

# Carregar o objeto completo do CellDataSet
full_cds <- readRDS("GSE202639_zperturb_full_cds.RDS")

# Carregar os metadados das células
cell_metadata <- read.csv("GSE202639_zperturb_full_cell_metadata.csv")

# Carregar os metadados dos genes
gene_metadata <- read.csv("GSE202639_zperturb_full_gene_metadata.csv")

# Carregar contagens
raw_counts <- readRDS("GSE202639_zperturb_full_raw_counts.RDS")

```

### Pre-processamento dos Dados Inicial
Dado o grande volume de dados e às limitações das máquinas este passo tornou-se demorado (tempo variável consoante a máquina). Avancei com a realização da Filtragem em Blocos, este passo é fundamental para os seguintes scripts correrem mais fluidamente ver documentação (é possível alocar mais um núcleo do PC para processar estes dados))
```{r prepoc1}
#gc() - #Garbage collection para libertar memória não utilizada, apagar #

# Configuração inicial
num_cores <- detectCores()
bpparam <- MulticoreParam(workers = num_cores - 2)

# Definição dos blocos
nblocks <- 10
block_size <- ceiling(ncol(sce) / nblocks)
blocks <- split(seq_len(ncol(sce)), cut(seq_len(ncol(sce)), breaks = nblocks))

# Função para processar cada bloco
process_block <- function(block) {
  sub_sce <- sce[, block]
  rowSums(counts(sub_sce) > 5, na.rm = TRUE) > 0
}

# Aplicação da função em paralelo
keep_genes_blocks <- bplapply(blocks, process_block, BPPARAM = bpparam)

# Consolidação dos resultados
keep_genes <- do.call(c, keep_genes_blocks)
sce <- sce[keep_genes, ]


# Análise de expressão dos genes e fatores de transcrição
# Preparar dados para análise
# Esta etapa será mais detalhada após revisão da teoria e determinação de métodos específicos
```

## Análise exploratória

```{r exam1}
# Explorar os tipos de células
unique(colData(full_cds)$cell_type_broad)
# Explorar os alvos dos genes
unique(colData(full_cds)$gene_target)
# Explorar as condições
unique(colData(full_cds)$condition) #parece não haver nada o que é de estranhar, vou continuar a avançar no entanto...
#celulas pigmentares:
#[55] "iridophore"
#[38] "melanophore"                                          
#[60] "xanthophore"                                          

```

## Plotar UMAPs com os dados em bruto

Com base nas informações e nesta pré-analise temos um conjunto de dados com vários tipos de células e alvos genéticos, mas ainda sem condições especificadas. Neste caso para realizar uma análise de expressão genética foquei-me apenas nos 3 diferentes tipos de celulas pigmentares que consegui identificar mais rapidamente : "melanophore," "iridophore," e "xanthophore," e plotei um UMAP com isto.

```{r UMAP1}
# Filtrar células pigmentares
pigment_cell_types <- c("melanophore", "iridophore", "xanthophore") #espero não estar a esquecer nenhuma

pigment_cds <- full_cds[, colData(full_cds)$cell_type_broad %in% pigment_cell_types]

# Calcular as coordenadas UMAP
if (!"UMAP" %in% reducedDimNames(pigment_cds)) {
  pigment_cds <- runUMAP(pigment_cds, dims = 1:10)
}

# Plotar UMAP
plotUMAP(pigment_cds, colour_by = "cell_type_broad") + 
  ggtitle("UMAP dos tipos de Células Pigmentares") +
  theme_minimal()
```
Para criar um gráfico UMAP para visualizar a expressão ao longo do tempo das celulas pigmentares, utilizei o `pigment_cds` definido anteriormente colorido pelo `timepoint`:

```{r UMAP2}
# UMAP ao longo do tempo do ensaio com as celulas pigmentares
plotUMAP(pigment_cds, colour_by = "timepoint") + 
  ggtitle("UMAP das celulas Pigmentares ao longo do tempo") +
  theme_minimal()
```
Por fim, para uma análise com os fatores de transcrição, usei a coluna `gene_target` no `colData` para colorir o gráfico UMAP, o que deve  permitir visualizar a distribuição dos diferentes fatores de transcrição.

```{r UMAP3}
# Gráfico UMAP colorido pelos fatores de transcrição
plotUMAP(pigment_cds, colour_by = "gene_target") + 
  ggtitle("UMAP das Células Pigmentares por Factores de Transcrição")
```
## Enriquecimento de Marcadores de Célula

Funções como `FindAllMarkers` ou `FindMarkers` do pacote Seurat permitem encontrar os marcadores celulares para cada cluster identificado.
A ideia é comparar a expressão entre os diferentes tipos de células pigmentares (`melanophore`, `iridophore`, `xanthophore`).

encontrei um problema de alocação de memória ao tentar criar um objeto DESeqDataSet a partir de uma matriz de contagens. A mensagem de erro cannot allocate vector of size 641.3 Gb indica que o R não é capaz de alocar um vetor deste tamanho (641GB) ou a maquina não esta preparada para alocar 641GB. Uma abordagem para contornar esse problema seria trabalhar com uma representação de dados esparsos, evitando a conversão para um formato denso, que requer uma grande quantidade de memória. O pacote DESeq2 permite trabalhar com matrizes diretamente através do uso do pacote Matrix para criar a matriz de contagens. Não está a funcionar

```{r enrimarker1}
# 'counts' já é uma matriz esparsa:
sparse_counts <- as(counts, "sparseMatrix")

# Assuming 'sparse_counts' is a sparse matrix of counts and 'coldata' has the necessary metadata
group <- factor(coldata$cluster)

# Create a DGEList object from sparse matrix
dge <- DGEList(counts=sparse_counts, group=group)

# Proceed with analysis using edgeR
dge <- calcNormFactors(dge)
design <- model.matrix(~ group)
dge <- estimateDisp(dge, design)
fit <- glmQLFit(dge, design)
result <- glmQLFTest(fit, coef=2) # Adjust 'coef' based on the comparison of interest
topTags(result)

```


## Perform differential expression analysis

Proximo passo? ... ainda em desenvolvimento...

```{r exam3}
#analise exploratoria do conteudo das colunas
names(colData(full_cds))

unique(colData(full_cds)$timepoint)
unique(colData(full_cds)$expt)
unique(colData(full_cds)$tissue)
unique(colData(full_cds)$gene_target)
unique(colData(full_cds)$embryo)
unique(colData(full_cds)$sample)


```

```{r difexp1}

# Extrair a matriz de contagens do objeto 'full_cds'
counts <- counts(full_cds)

# Obter os metadados de coluna (dados de amostra), que devem incluir a coluna 'cluster'
coldata <- colData(full_cds)

# Criar um objeto DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = coldata,
                              design = ~ cluster)

# Prossiga com a análise DESeq
dds <- DESeq(dds)

# Obter os resultados para comparações específicas de tempo
results_1_vs_2 <- results(dds, contrast = c("timepoint", "1", "2"))

# Visualizar os principais resultados
head(results_1_vs_2)

```

## Cell type-specific differential expression analysis for a perturbation

```{r pressure, echo=FALSE}

# Load the zebrafish perturbation data
perturb_cds <- readRDS("zscape_perturb_cds.RDS")

# List the different genetic perturbations 
unique(colData(perturb_cds)$gene_target)

# Subset smoothened crispants and notochord cells (for example)
smo_nc_cds <- perturb_cds[,colData(perturb_cds)$gene_target %in% c("smo", "ctrl-inj") & 
            colData(perturb_cds)$cell_type_broad %in% c("notochord")]

# Now select the timepoints 
# note that the controls will include timepoints that are not included for smo
smo_nc_cds <- smo_nc_cds[,colData(smo_nc_cds)$timepoint %in% c("24", "36")]

# Use monocle3 to perform DE testing between controls and smo notochord cells
deg_cds <- smo_nc_cds[Matrix::rowSums(SingleCellExperiment::counts(smo_nc_cds) > 0) > 10,] # filter for expressed genes
fits <- fit_models(deg_cds, model_formula_str = "~gene_target", cores = 4)
mod_coef <- coefficient_table(fits)

# Parse the results table
smo.celltype.degs <- mod_coef %>% 
  mutate(up_in = case_when(
    estimate < 0 ~ "ctrl",
    estimate > 0 ~ "smo"))

smo.celltype.degs <- smo.celltype.degs %>% 
    filter(term != "(Intercept)") %>%
    select(up_in, id, gene_short_name, q_value, estimate, -model_summary, -model)

# filter for q-value < 0.05
sig.smo.celltype.degs <- smo.celltype.degs %>%
            filter(q_value < 0.05 ) %>%  
            arrange(up_in, q_value)

# check the deg number for each direction
sig.smo.celltype.degs %>% 
    group_by(up_in) %>%
    tally()

# save the differentially expressed genes as a csv
fwrite(sig.smo.celltype.degs, "smo_nc_24-36h_q05_degs.csv", 
        sep = ",", na = "NA")


#Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
```